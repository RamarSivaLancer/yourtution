"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_child_process_1 = require("node:child_process");
const architect_1 = require("@angular-devkit/architect");
const strings_1 = require("@angular-devkit/core/src/utils/strings");
/**
 * Converts the options object back to an argv string array.
 *
 * @example
 * buildArgs({"workers": 2}); // returns ["--workers", 2]
 */
function buildArgs(options) {
    var _a;
    // extract files
    const filesArgs = (_a = options.files) !== null && _a !== void 0 ? _a : [];
    options.files = null;
    return [
        ...filesArgs,
        ...Object.entries(options).flatMap(([key, value]) => {
            // Skip builder-internal options
            if (key === 'devServerTarget') {
                return [];
            }
            // Skip objects, arrays, null, undefined (should already be validated by Angular though)
            if (typeof value === 'object' ||
                Array.isArray(value) ||
                value === null ||
                value === undefined) {
                return [];
            }
            // options automatically got converted to camelCase, so we have to convert them back to kebab-case for Playwright.
            const dashes = key.length === 1 ? '-' : '--';
            const argument = `${dashes}${(0, strings_1.dasherize)(key)}`;
            if (typeof value === 'boolean') {
                if (value) {
                    return argument;
                }
                return [];
            }
            return [argument, String(value)];
        }),
    ];
}
function startDevServer(context, devServerTarget) {
    return __awaiter(this, void 0, void 0, function* () {
        const target = (0, architect_1.targetFromTargetString)(devServerTarget);
        const server = yield context.scheduleTarget(target, {});
        return server;
    });
}
function startPlaywrightTest(options, baseURL) {
    return __awaiter(this, void 0, void 0, function* () {
        // PLAYWRIGHT_TEST_BASE_URL is actually a non-documented env variable used
        // by Playwright Test.
        // Its usage in playwright.config.ts is to clarify that it can be overriden.
        let env = process.env;
        if (baseURL) {
            env = Object.assign({ PLAYWRIGHT_TEST_BASE_URL: baseURL }, process.env);
        }
        return new Promise((resolve, reject) => {
            const childProcess = (0, node_child_process_1.spawn)('npx playwright test', buildArgs(options), {
                cwd: process.cwd(),
                stdio: 'inherit',
                shell: true,
                env,
            });
            childProcess.on('exit', (exitCode) => {
                if (exitCode !== 0) {
                    reject(exitCode);
                }
                resolve(true);
            });
        });
    });
}
function runE2E(options, context) {
    return __awaiter(this, void 0, void 0, function* () {
        let server = undefined;
        let baseURL = '';
        try {
            if (options.devServerTarget &&
                typeof options.devServerTarget === 'string') {
                server = yield startDevServer(context, options.devServerTarget);
                const result = yield server.result;
                baseURL = result.baseUrl;
            }
            yield startPlaywrightTest(options, baseURL);
            return { success: true };
        }
        catch (error) {
            return { success: false };
        }
        finally {
            if (server) {
                server.stop();
            }
        }
    });
}
exports.default = (0, architect_1.createBuilder)(runE2E);
