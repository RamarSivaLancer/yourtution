"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ngAdd;
const schematics_1 = require("@angular-devkit/schematics");
const tasks_1 = require("@angular-devkit/schematics/tasks");
function ngAdd(options) {
    return (tree, context) => {
        const copyFiles = (0, schematics_1.mergeWith)((0, schematics_1.apply)((0, schematics_1.url)('./files'), [(0, schematics_1.move)('.')]));
        const rules = [
            updateAngular,
            addNpmScript,
            gitignore,
            copyFiles,
            addPlaywright,
        ];
        if (options.installBrowsers) {
            context.addTask(new tasks_1.RunSchematicTask('install-browsers', {}));
        }
        return (0, schematics_1.chain)(rules)(tree, context);
    };
}
function updateAngular(tree, context) {
    if (!tree.exists('angular.json')) {
        return tree;
    }
    context.logger.debug('angular.json');
    const sourceText = tree.readText('angular.json');
    const json = JSON.parse(sourceText);
    for (const projectName of Object.keys(json.projects)) {
        json.projects[projectName].architect.e2e = {
            builder: 'playwright-ng-schematics:playwright',
            options: {
                devServerTarget: `${projectName}:serve`,
            },
            configurations: {
                production: {
                    devServerTarget: `${projectName}:serve:production`,
                },
            },
        };
    }
    tree.overwrite('angular.json', JSON.stringify(json, null, 2));
    return tree;
}
function addNpmScript(tree, context) {
    if (!tree.exists('package.json')) {
        return tree;
    }
    context.logger.debug('npm script');
    const key = 'e2e';
    const value = 'ng e2e';
    const sourceText = tree.readText('package.json');
    const json = JSON.parse(sourceText);
    if (!json.scripts[key]) {
        json.scripts[key] = value;
    }
    tree.overwrite('package.json', JSON.stringify(json, null, 2));
    return tree;
}
function gitignore(tree, context) {
    if (!tree.exists('.gitignore')) {
        return tree;
    }
    context.logger.debug('Adjust .gitignore');
    const content = tree.readText('.gitignore');
    const modifiedContent = `${content}
# Playwright
/test-results/
/playwright-report/
/playwright/.cache/
`;
    tree.overwrite('.gitignore', modifiedContent);
    return tree;
}
function getLatestNpmVersion(packageName) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a;
        try {
            const response = yield fetch(`https://registry.npmjs.org/${packageName}`);
            const responseObject = yield response.json();
            const version = (_a = responseObject['dist-tags'].latest) !== null && _a !== void 0 ? _a : 'latest';
            return version;
        }
        catch (error) {
            return 'latest';
        }
    });
}
function addPackageToPackageJson(tree, context, pkg, version) {
    return () => {
        if (!tree.exists('package.json')) {
            return tree;
        }
        context.logger.debug('Adjust package.json');
        const sourceText = tree.readText('package.json');
        const json = JSON.parse(sourceText);
        if (!json.devDependencies) {
            json.devDependencies = {};
        }
        if (!json.devDependencies[pkg]) {
            json.devDependencies[pkg] = version;
        }
        json.devDependencies = sortObjectByKeys(json.devDependencies);
        tree.overwrite('package.json', JSON.stringify(json, null, 2));
        return tree;
    };
}
function addPlaywright(tree, context) {
    return __awaiter(this, void 0, void 0, function* () {
        context.logger.debug('Updating dependencies...');
        const version = yield getLatestNpmVersion('@playwright/test');
        context.logger.info(`Adding @playwright/test ${version}`);
        context.addTask(new tasks_1.NodePackageInstallTask({ allowScripts: true }));
        return addPackageToPackageJson(tree, context, '@playwright/test', version);
    });
}
function sortObjectByKeys(obj) {
    return Object.keys(obj)
        .sort()
        .reduce((result, key) => {
        return Object.assign(Object.assign({}, result), { [key]: obj[key] });
    }, {});
}
